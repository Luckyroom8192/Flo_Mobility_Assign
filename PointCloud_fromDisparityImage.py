# -*- coding: utf-8 -*-
"""Untitled24.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19PtOb3PdSnOKtpO_0h9RwBo77uIp-Xly
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def calculate_cartesian_coordinates(disparity_map, K, baseline):
    fx = K[0, 0]
    fy = K[1, 1]
    cx = K[0, 2]
    cy = K[1, 2]

    #Calculating depth map from given disparity image
    depth_map = (fx*baseline)/disparity_map

    height, width = disparity_map.shape
    coordinates= np.zeros((height, width, 3))

    #Calculating Cartesian coordinates (x, y, z) for each pixel
    for v in range(height):
        for u in range(width):
            d = depth_map[v, u]
            x = (u-cx)*d/fx
            y = (v-cy)*d/fy
            z = d
            coordinates[v, u] = [x, y, z]

    return coordinates

disparity_map = cv2.imread('/content/Disparity.png', cv2.IMREAD_GRAYSCALE)
K = np.array([[398.7956237792969, 0.0, 315.4751892089844],
              [0.0, 398.7956237792969, 205.1688232421875],
              [0, 0, 1]])
baseline = 0.075

cartesian_coordinates = calculate_cartesian_coordinates(disparity_map, K, baseline)

def plot_3d_point_cloud_bf(coordinates):
    points_flat = coordinates.reshape((-1, 3))

    # Extract x, y, z coordinates
    x = points_flat[:, 0]
    y = points_flat[:, 1]
    z = points_flat[:, 2]

    # Create a new figure for the 3D plot
    fig = plt.figure(figsize=(8, 6))
    ax = fig.add_subplot(111, projection='3d')

    # Plot the 3D point cloud with a color map based on z-coordinates
    sc = ax.scatter(z, x, y, c=z, cmap='viridis', s=1)
    ax.view_init(elev=5, azim=0)
    plt.gca().invert_zaxis()
    plt.gca().invert_xaxis()

    # Add colorbar
    cbar = fig.colorbar(sc, ax=ax, label='Z')  # Create colorbar based on z-coordinate

    # Set labels and title
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_title('3D Point Cloud from Cartesian Coordinates in camera frame')

    # Show the plot
    plt.show()

# Visualize the 3D point cloud
plot_3d_point_cloud_bf(cartesian_coordinates)

T_bf_cam = np.array([[0.0, 0.0, 1.0, 0.28],
                     [-1.0, 0.0, 0.0, 0.0375],
                     [0.0, -1.0, 0.0, 0.28],
                     [0.0, 0.0, 0.0, 1.0]])

def transform_cartesian_coordinates(cartesian_coordinates, transformation_matrix):
    points_flat = cartesian_coordinates.reshape((-1, 3))
    #making points homogenous
    num_points = points_flat.shape[0]
    points_homogeneous = np.hstack((points_flat, np.ones((num_points, 1))))

    transformed_points_homogeneous = np.dot(transformation_matrix, points_homogeneous.T).T

    #extracting the cartesian coordinates from the homogenous values calculated after applying transformation to base frame
    transformed_points_cartesian = transformed_points_homogeneous[:, :3] / transformed_points_homogeneous[:, 3][:, np.newaxis]

    return transformed_points_cartesian

transformed_coordinates = transform_cartesian_coordinates(cartesian_coordinates, T_bf_cam)

def plot_3d_point_cloud(coordinates):
    points_flat = coordinates.reshape((-1, 3))

    x = points_flat[:, 0]
    y = points_flat[:, 1]
    z = points_flat[:, 2]

    fig = plt.figure(figsize=(8, 6))
    ax = fig.add_subplot(111, projection='3d')

    # Plotting the 3D point cloud
    sc = ax.scatter(x, y, z, c=z, cmap='viridis', s=1)
    plt.colorbar(sc, label='Depth')  # Add colorbar with depth values
    plt.gca().invert_yaxis()

    # Set labels and title
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_title('3D Point Cloud after Transformation to base frame')
    ax.view_init(elev=5, azim=0)

    # Show the plot
    plt.show()

# Assuming 'transformed_coordinates' contains the transformed 3D point cloud
plot_3d_point_cloud(transformed_coordinates)